<h1 id="section"></h1>
<p>This is a quick post, with the purpose of sharing the idea of Multi-resolution Dynamic Mode Decomposition. It's a simple yet very clever extension of the Vanilla Dynamic Mode Decomposition, about which I wrote <a href="https://gpir.es/posts/notes-on-dynamic-mode-decomposition/">on another post</a></p>
<p>I wrote it while learning about the topic, so it's mostly for myself. For a much better explanation, please check:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=E1dNE02LaCE">This video abstract</a></li>
<li><a href="https://arxiv.org/pdf/1506.00564.pdf">The original paper</a></li>
</ul>
<h1 id="section-1"></h1>
<p>DMD allows us to find the linear dynamical system that best describes the data we have at hand. I.e., it finds a matrix <span class="math inline"><em>A</em></span> that turns <span class="math inline">$\frac{dx}{dt} = Ax$</span> into a good approximation of the system where our data comes from.</p>
<h2 id="section-2"></h2>
<p>This in turn allows us to write down our system as a combination of eigenfunctions and DMD modes:</p>
<h3 id="section-3"></h3>

<h2 id="section-4"></h2>
<p>The idea of multi-resolution DMD starts with separating that sum into "slow modes" and "fast modes". These are distinguished by their frequencies <span class="math inline"><em>ω</em><sub><em>k</em></sub></span>. So we rewrite the above as:</p>
<h3 id="section-5"></h3>

<h3 id="section-6"></h3>
<p>The threshold for what is considered a slow mode versus a fast mode is obviously tunable. One sensible thing to do is to look at the singular values and how they distribute about the origin, define a maximum radius and divide the modes according to what singular values lie inside or outside the radius.</p>
<h3 id="section-7"></h3>
<p>After distinguishing the slow and fast modes, we subtract the slow modes from the data and we split the data in 2. Now we apply the previous procedure on each of the chunks. At the end we split each of the chunks in 2, and so on.</p>
<h3 id="section-8"></h3>
<p>After going as deep as we want in this hierarchy, we can rewrite the system as:</p>
<ol>
<li><p>Where:</p>
<ul>
<li><span class="math inline"><em>f</em><sub><em>l</em>, <em>j</em></sub>(<em>t</em>)</span> is a "switch" that is on when <span class="math inline"><em>t</em> ∈ [<em>t</em><sub><em>j</em></sub>, <em>t</em><sub><em>j</em> + 1</sub>]</span></li>
<li><span class="math inline"><em>l</em> = 1, 2, ..., <em>L</em></span> is the decomposition level (<span class="math inline"><em>L</em></span> is the deepest level)</li>
<li><span class="math inline"><em>j</em> = 1, 2, ..., <em>J</em></span> is the number of subdivisions per decomposition level (<span class="math inline"><em>J</em> = 2<sup>(<em>l</em> − 1)</sup></span> since we're always splitting in two)</li>
<li><span class="math inline"><em>k</em> = 1, 2, ..., <em>m</em><sub><em>L</em></sub></span> is the mode index (<span class="math inline"><em>m</em><sub><em>L</em></sub></span> is the max mode index at level <span class="math inline"><em>L</em></span>)</li>
<li><span class="math inline"><em>ξ</em></span> are the spatial coordinates</li>
</ul></li>
</ol>
<h3 id="section-9"></h3>
<p>This basically allows us to have a local system per <span class="math inline">(<em>l</em>, <em>j</em>)</span>:</p>
